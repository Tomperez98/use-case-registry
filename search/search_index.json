{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is this?","text":"<p>This library builds a set of core components I like to use when developing software. The documentation written here aims to be both a practice for me on writting documentation of my own projects and, most importantly, to explain the logic and reasons why I believe this library is useful for writting software.</p>"},{"location":"#what-does-the-library-implement","title":"What does the library implement?","text":""},{"location":"#usecaseregistry-object","title":"<code>UseCaseRegistry</code> object","text":"<p>It's basically a fully typed <code>list</code> that is instantiated defining a max length. The utility of this object is to be injected into each use case defined workflow to collect a set of write operations that will be executed later, in the workflow, as an ACID transaction against the application database.</p> <p>Note: I do know that libraries like <code>SQLAlchemy</code> use context managers to implement the Unit Of Work pattern and that essentially everything that happens within the context will be executed as a transaction when triggering the <code>__exit__</code> magic method. But, after working with other type of databases that support ACID transactions (such as <code>DynamoDB</code>) I've found that this idea of a container that collects a set of operations is easier to generalize and to extend.</p> <pre><code>from use_case_registry import UseCaseRegistry\n\nMAX_SUPPORTED_WRITE_OPERATIONS = 100\n\nwrite_ops_registry = UseCaseRegistry[str](max_length=10)\n# UseCaseRegistry[int](max_length=3)\n# UseCaseRegistry[Any](max_length=MAX_SUPPORTED_WRITE_OPERATIONS)\n\nwrite_ops_registry.add_value(v=\"INSERT INTO...\")\nwrite_ops_registry.add_value(v=\"INSERT INTO...\")\nwrite_ops_registry.add_value(v=\"INSERT INTO...\")\n\ncommit_as_transaction(write_operations=write_ops_registry.get_state())\n</code></pre>"},{"location":"#icommand-interface","title":"<code>ICommand</code> interface","text":"<p>The <code>Command</code> is a behavioral design pattern that turns a request into a stand-alone object that contains all information about the request (see Refactoring Guru). In this library the interface defines that all concrete implementations must implement a method called <code>validate</code> and a method called <code>execute</code>. </p> <p>The <code>validate</code> method returns either success, meaning all input arguments to the command class are valid (given the core logic context) or returns a <code>CommandInputValidationError</code> meaning at least one input argument is not valid.</p> <p>Within the <code>execute</code> method you would write the logic to complete an application use case. Each use case is implementented as a workflow composed by a logic sequence of steps that are required to successfully complete the request (see One Use Case, One Workflow).</p> <pre><code>from result import Err, Ok, Result\n\nfrom use_case_registry import UseCaseRegistry\nfrom use_case_registry.base import ICommand\nfrom use_case_registry.errors import CommandInputValidationError\n\n\nclass GreetingCommand(ICommand):\n\"\"\"A concrete command implementation.\"\"\"\n\n    def __init__(self, name: str, last_name: str, age: int) -&gt; None:\n\"\"\"ConcreteCommand constructor.\"\"\"\n        self.name = name\n\n        self.database = IDatabase()\n\n    def validate(self) -&gt; Result[None, CommandInputValidationError]:\n\"\"\"Validate command inputs are valid.\"\"\"\n        if not self.name.isascii():\n            return Err(CommandInputValidationError())\n\n        return Ok()\n\n    def _compose_greeting(self) -&gt; str:\n        return f\"Hi {self.name}\"\n\n    def execute(\n        self, write_ops_registry: UseCaseRegistry[str]\n    ) -&gt; Result[str, Exception]:\n\"\"\"Execute the workflow.\"\"\"\n        composed_greeting = self._compose_greeting()\n\n        # This is deterministic. We are adding a string to the `UseCaseRegistry`\n        self.database.increase_number_of_greeting_done(\n            write_ops_registry=write_ops_registry\n        )\n\n        # This is not deterministic so an error handling has to be implemented.\n        success_or_err = self.database.commit_transacation(\n            write_ops_registry=write_ops_registry\n        )\n        err = success_or_err.err()\n        if err is not None:\n            # handle error\n            return Err(RuntimeError())\n\n        return Ok(composed_greeting)\n</code></pre>"},{"location":"general-thoughts/clean-architecture/","title":"Clean Architecture","text":"<p>Framework Agnostic</p> <p>Core business logic is more stable that framework decisions. Either you are exposing your application via a CLI, RestAPI, gRPC, or even as a Slack/WhatsApp application the business use cases supported should be the same across the Presentation Layer you are using.</p> <p>Of course, this also applied to whether you are using an specif framework for you API (<code>FastAPI</code>, <code>Django</code>, <code>Flask</code>, etc) or your CLI (<code>parseargs</code>, <code>click</code>, <code>Typer</code>, etc) whatever you decide you use where, should not be couple to the core logic of your application.</p> <p>Database Agnostic</p> <p>The way you decide to store your application entities, models, aggregates, objects... in the persistance layer (a.k.a database) shouldn't constraint the capabilities of your application. In fact, you should decouple your core business logic from your database implementation using the repository pattern, basically you're application knows about the interface the database must implement, whether the implementation uses a <code>DynamoDB</code> or a <code>PostgresSQL</code> database is something the core business logic doesn't care about.</p>"},{"location":"general-thoughts/error-handling/","title":"Error Handling","text":"<p>Happy \ud83d\ude00 vs unhappy \ud83e\udee0 path</p> <p>When we write software we tend to only think in the happy path, the flow the software will go through in the default scenario featuring no exceptional or error conditions. Happy path test is a well-defined test case using known input, which executes without exception and produces and expected output. Happy path testing can show that a system meets its functional requirements but it doesn't guarantee a graceful handling of error conditions or aid in fiding hidden bugs.</p> <p>In use case analysis, there is only one happy path, but there may be any number of additional alternate path scenarions which are all valid optional outcomes. If valid alternatives exist, the happy path is then identified as the default or most likely positive alternative. The analysis may also show one or more exception paths. An exception path is takes as result of a fault condition.</p> <p><code>Result</code> typing and error handling inspired in <code>rust-lang</code></p> <p>Modern languages like <code>rust</code> and <code>go</code> have a completely different ways to propagate errors, compared to languages like <code>python</code>, <code>java</code> or <code>javascript</code>. In the last, you'd basically raise or throw and exceptions and then wrap whatever code may failed between a <code>try/except</code> or <code>try/catch</code> clause.</p> <p>In constrast, <code>rust</code> and <code>go</code> both implement something different. Not deterministic1 code will return both the result of the code execution or an error associated with the failure of the code execution. That's why you would see code like this many times when reading code base on this languages.</p> <pre><code>f, err := os.Open(\"filename.txt\")\nif err != nil {\nlog.Fatal(err) // handled error\n}\n// continue\n</code></pre> <pre><code>let file = File::open(\"main.jpg\");\nlet file_err = file.as_ref().err();\nif file_err.is_some() {\nprintln!(\"File not found!\") // handled error\n}\n// continue\n</code></pre> <p>The greatest advantage for software developers for this type of error propagation system is that error are also part of the typing annotation of the functions. So whoever is calling that piece of code, is required to propery handled failure cases if not the compiler will cry. (Or the <code>static type checker</code> in case of Python.)</p> <p>Another advantage is that languages like <code>rust</code> and <code>go</code> separate errors in two categories: - Non-Recoverable Errors (e.g., non-checked out of bounds array access.) - Recoverable Errors (e.g., function failures.)</p> <p>By definition, <code>Non-Recoverable Errors</code> will crash your system while <code>Recoverable Errors</code> are propagated to the client to be propertly handled. But the system won't break because of those.</p> <ol> <li> <p>A deterministic code is a code that, given a certain input, will always return produce the same output, with the underlaying machine always passing throw the same sequence of steps. Formally, a deterministic algorithm computes a mathematical function; a function has a unique value for any input in its domain, and the algorithm is a process that produces this particular value as output. In contrast, a non deterministic code is code that, for a variety of factors, can cause an algorithm to behave in a way which is not expected.\u00a0\u21a9</p> </li> </ol>"},{"location":"general-thoughts/one-use-case-one-workflow/","title":"One Use Case, One Workflow","text":"<p>Use case modeled as a workflow</p> <p>Use cases can be thought as a set of orchestrated steps that are executed until completion (think about step functions, airflow, temporal, etc). These steps can (1) interact with third-party services (2) interact with the system database, and (3) perform in-memory operations that do calculations.</p> <p>Aim for durable execution and idempotency</p> <p>You want to write your workflows in a way that the retrial of the steps do not cause the system to end up in an inconsistent state. Now, this is not 100% achievable if you are not building you application in a durable execution platform. But you can still apply most of these principles.</p> <p>To do this you want to split you workflow into two parts, the first part would go from start up to the commit of an atomic transaction againt the application database. In this part you want to limit the code to only invoking <code>query</code>1 operations and modifying application models in memory, this part would end when the changes are committed as an ACID transaction against the application database.</p> <p>The second part starts after the commit of the state changes up to the end of the workflow execution. This part would invoke <code>command</code>2 operations against third-party services. Thinks like sending notification via email, SMS, WhatsApp, or sending analytics on application usage to other services, goes here. The reason why this implementation won't be 100% durable is that, with API requests, in case of failure the best think you can do is to retry the call n-number of times (Durable execution platforms would ensure these steps are retried indefinatelly up until completion).</p> <ol> <li> <p>Operations that request information on the current state of a system but do not alter the state. Idempotent by definition.\u00a0\u21a9</p> </li> <li> <p>Operations that do modify the state of a system. Not idempotent by default (you could use an idempotency key).\u00a0\u21a9</p> </li> </ol>"}]}